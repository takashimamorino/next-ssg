"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var setCache = function () { };
var makeCache = function () {
    var configs = {};
    // the data cache
    var cache = new Map(); // data:  { '/path': 'associated data' }
    // the error cache
    var errors = {};
    // const listeners = []
    var listeners = {};
    // const data = {}
    var promises = {}; // suspense
    var revalidators = {}; // what will call api in background, set cache, then rerender component
    var focusRevalidators = {};
    var expirations = {};
    function configure(path, _a) {
        var persist = _a.persist, cachePolicy = _a.cachePolicy, cacheLife = _a.cacheLife, rest = __rest(_a, ["persist", "cachePolicy", "cacheLife"]);
        configs[path] = __assign({ persist: persist, cachePolicy: cachePolicy, cacheLife: cacheLife }, rest);
        expirations[path] = Date.now() + cacheLife;
    }
    function getLocalCache(path) {
        return Object.defineProperties({
            promise: promises[path],
            promises: promises,
            error: errors[path],
            has: function (key) { return cache.has(key); },
            errors: errors,
            listeners: listeners[path],
            notify: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return notify.apply(void 0, __spreadArrays([path], args));
            },
            set: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return set.apply(void 0, __spreadArrays([path], args));
            },
            get: function () { return cache.get(path); },
            remove: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return remove.apply(void 0, __spreadArrays([path], args));
            },
            clear: clear,
            subscribe: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscribe.apply(void 0, __spreadArrays([path], args));
            },
            unsubscribe: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscribe.apply(void 0, __spreadArrays([path], args));
            }
        }, {
            data: { get: function () { return cache.get(path); } },
            promise: {
                set: function (p) { promises[path] = p; },
                get: function () { return promises[path]; }
            },
            isStale: { get: function () { return !expirations[path] || expirations[path] < Date.now(); } }
        });
    }
    // function get (path, { persist, cachePolicy, cacheLife }) {}
    function set(path, value, shouldNotify) {
        if (shouldNotify === void 0) { shouldNotify = true; }
        cache.set(path, value);
        expirations[path] = Date.now() + configs[path].cacheLife;
        if (shouldNotify)
            notify(path, value, false);
        // notify()
    }
    // function keys (path, { persist, cachePolicy, cacheLife }) {}
    // function has (path, { persist, cachePolicy, cacheLife }) {}
    function clear(shouldNotify) {
        if (shouldNotify === void 0) { shouldNotify = true; }
        if (shouldNotify)
            cache.forEach(function (path) { return notify(path, null, false); });
        cache.clear();
        // notify()
    }
    function remove(path, shouldNotify) {
        if (shouldNotify === void 0) { shouldNotify = true; }
        if (shouldNotify)
            setCache(path, null, false);
        cache.delete(path);
        // notify()
    }
    function subscribe(path, listener) {
        if (typeof listener !== 'function') {
            throw new Error('Expected the listener to be a function.');
        }
        // let isSubscribed = true
        if (!listeners[path])
            listeners[path] = [];
        listeners[path].push(listener);
        // return () => {
        //   if (!isSubscribed) return
        //   isSubscribed = false
        //   const index = listeners.indexOf(listener)
        //   if (index > -1) {
        //     listeners[index] = listeners[listeners.length - 1]
        //     listeners.length--
        //   }
        // }
    }
    function unsubscribe(path, listener) {
        if (typeof listener !== 'function') {
            throw new Error('Expected the listener to be a function.');
        }
        var index = listeners.indexOf(listener);
        if (index > -1) {
            listeners[index] = listeners[listeners.length - 1];
            listeners.length--;
        }
    }
    // Notify Cache subscribers about a change in the cache
    function notify(path) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (listeners[path]) {
            if (utils_1.isFunction(args[0]))
                return listeners[path].forEach(args[0]);
            listeners[path].forEach(function (l) { return l.apply(void 0, args); });
        }
        else {
            console.log('There are no listeners ðŸ˜…');
        }
    }
    return Object.defineProperties({
        configure: configure,
        // subscribe,
        get: function (k) { return cache.get(k); },
        set: set,
        keys: function () { return Array.from(cache.keys()); },
        has: function (k) { return cache.has(k); },
        clear: clear,
        delete: remove,
        getLocalCache: getLocalCache
        // promises,
        // revalidators,
        // focusRevalidators,
        // errors
    }, {
        data: {
            // we have this as a getter for performance
            get: function () { return Array.from(cache).reduce(function (acc, _a) {
                var _b;
                var k = _a[0], v = _a[1];
                return (__assign(__assign({}, acc), (_b = {}, _b[k] = v, _b)));
            }, {}); }
        }
    });
};
var theCache = makeCache();
// window.myCache = theCache
exports.default = theCache;
//# sourceMappingURL=cache.js.map